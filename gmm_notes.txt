** Sampling over the Euclidean distance (sqrt(...))
- if given a point not in the training data (demons), the GMR cannot regress 
and/or perfrom arbitrarly -- generates poses in the opposite direction (??!! not 
in the opposite direction, it just regresses outside the gaussians of the GMM)


** Sample over each axis (xyz) separately 

TODO:
- Clean the code
- Display info about the learned GMM/trajectory (in a topic and/or service)
- Visualize the GMM in RViz
- Visualize the learned trajectory in RViz
- Save the learned trajectory
- Save the GMM in a file
- Record data and a video for each modelling trial I did for documentation
  1- targetPoseError vs delta pose for each axis (3 GMMs)
    - it goes to the target pose, it doesn't follow the trajectory because the 
      3 axis were de-coupled.
  2- targetPoseError vs absolute pose for each axis (3 GMMs)
    - Similar to delta poses; the behaviour is linear, i.e. it behaves as a normal 
      position controller. This probably explains why it is slow and even works if given
      pose outside the GMM, unlike the delta pose where it fails to converge when given
      a pose outside the GMM.
  3- targetPoseError (Euclidean distance) vs absolute pose (1 GMM) (To be recorded)
    - Works perfect. It can return back inside the GMM if robot is externally pushed away
      from the path while executing the learned trajectory, UNLESS pose is given outside the GMM  
  4- targetPoseError (Euclidean distance) vs delta pose (1 GMM) (DONE)

___________ After DMP

- Compare taking the gmm_learned_trajectory from moving the robot in simulation vs calculating
the points of the trajectory. [Can add an if condition in the launch file to switch between
simulation and real]
- Add actionlib to have the option to move the robot (in simulation or in real) with the
learned_trajectory. (DONE but not entirely!!)
- Save the GMM model of each task (in a file). (will record /gmm_mix topic)
- Save the gmm_learned_trajectory (DONE)
- Add orientation

ToTry:
- Visualize the learned Poses (deltas)
- Learn each axis separately with zeroing the others to debug
- Increase the number of gaussians
- Try taking the 3 decimal points of the numbers instead of the whole decimal points
- Stretch out the delta values (in the y -axis) because the differences are too small.
So try to multiply the values by 2 (or more).
- Train with absolute poses without the deltas (velocities) to see if the problem is 
with the deltas or the problem is with learning separate GMMs.
- Regress over the delta poses of the longest/shortest demon instead of the actual 
current pose of the robot.
- TOMORROW (14/04) visualize the data for regressing over delta poses. 

___________ After DMP
- test the DMP with one demonsatration, without using GMM-GMR.
- test with moving with learned_traj in different speeds (sending rates (hz))


Problems:
- In regression, if the point is outside the GMM, the GMR fails to converge.
- 

Possible Solutions:
- Modfiy the mean position of the learned gaussians according to the new 
starting/ending pose.

Bugs found:
- the queues size on the published topics (/gmm/learned_pose), and the delay in doReregression()
- possArr in gmm_node was being defined with push_back() which is wrong.

Ideas:

  New Idea to utilize strategy 3 and 4 in order to generalize the trajectory learning 
  to work with different starting and target poses:
    First collect delta poses of each demon and record them as delta demons. These delta
    demons are delta pose vs poseError. Generate, from these delta demons, absolute demons.
    This generated absolute demons can be utilized in two ways (ideas):
    - they can be used only for the purpose of visualizing the GMM in RViz. The GMM will
      be trained on delta poses vs poseError.
    - they can be used for training the GMM (absolute poses vs poseError). 
    
  What if the Cosine Similarity distance is used instead of the Euclidean distance?!!
  - still won't work with absolute poses.

  Regress for delta pose over time samples
  - The delta pose for each Demon will be extracted and then used to make new Demons
  - After that, DTW can be used (or not!)
  - 